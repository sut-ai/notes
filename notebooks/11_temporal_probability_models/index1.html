---
layout: content
metadata: notebooks_11_temporal_probability_models_metadata
colab: https://colab.research.google.com/github/sut-ai/notes/blob/master/notebooks/11_temporal_probability_models/index1.ipynb/index.ipynb
---

<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="Probabilistic-Reasoning-Over-Time">Probabilistic Reasoning Over Time<a class="anchor-link" href="#Probabilistic-Reasoning-Over-Time">¶</a></h1><p>Up to now, agents we have worked with, used their current data provided by their sensors to choose their action. Yet, they have much more than that. They've seen the past. In this chapter we will talk about agents that can perceive the world their in, how it works, and can quantify the degree of <strong>belief</strong> they have in their perception.</p>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><img alt="decorative" src="/notes/assets/notebooks/11_temporal_probability_models/resource/decorative_1.png"/></p>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Time-and-Uncertainty">Time and Uncertainty<a class="anchor-link" href="#Time-and-Uncertainty">¶</a></h2><p>Let's discuss the change we're making to the scope of problems we're solving. We have developed our techniques for  probabilistic reasoning in the context of static worlds, in which each random variable has a single fixed value. For  example, when repairing a car, we assume that whatever is broken remains broken during the process of diagnosis; our job
is to infer the state of the car from observed evidence, which also remains fixed.</p>
<p>Now consider a slightly different problem: treating a diabetic patient. As in the case of car repair, we have evidence such as recent insulin doses, food intake, blood sugar measurements, and other physical signs. The task is to assess the current state of the patient, including the actual blood sugar level and insulin level. Given this information, we can make a decision about the patient’s food intake and insulin dose. Unlike the case of car repair, here the dynamic aspects of the problem are essential. Blood sugar levels and measurements thereof can change rapidly over time, depending on recent food intake and insulin doses, metabolic activity, the time of day, and so on. To assess the current state from the history of evidence and to predict the outcomes of treatment actions, we must model these changes.</p>
<p>The same considerations arise in many other contexts, such as speech recognition, robot localization, user attention, medical monitoring, etc.</p>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="States">States<a class="anchor-link" href="#States">¶</a></h3><p>We view the world as a series of snapshots, or time slices, each of which contains a set of random variables. (Uncertainty over continuous time can be modeled by stochastic differential equations, SDEs. The models studied in this chapter can be viewed as discrete-time approximations to SDEs.)</p>
<p>To model our problems, we first start with <strong>Markov chains</strong>, and will continue to adopt it to better meet our real world requirements.</p>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h4 id="Markov-Chain">Markov Chain<a class="anchor-link" href="#Markov-Chain">¶</a></h4><p>A Markov process is a stochastic process that satisfies the <strong>Markov property</strong> (sometimes characterized as <strong>memorylessness</strong>). In simpler terms, it is a process for which predictions can be made regarding future outcomes based <em>solely</em> on its present state and—most importantly—such predictions are just as good as the ones that could be made knowing the process's full history. In other words, conditional on the present state of the system, its future and past states are independent.</p>
<p>A <strong>Markov chain</strong> is a type of Markov process that has either a discrete state space or a discrete index set (often representing time), but the precise definition of a Markov chain varies. Here, we use Markov chains that have a time as their discrete index set.</p>
<p>We define $X_t$ the <strong>state</strong> of the world in out problem at time $t$, i.e. $t$th snapshot we have.</p>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><img alt="Markov chain" src="/notes/assets/notebooks/11_temporal_probability_models/resource/markov_chain.png"/></p>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>As we said before, $X_t$ relies only on $X_{t-1}$, so the bayes net for a Markov chain would be as the above figure.</p>
<p>We define <strong>transition probabilities</strong> or <strong>dynamics</strong>, the CPT of $X_i|X_{i-1}$. Doing this, we have made an assumption about how the states are evolving, transition probabilities are the same at all times. This is called <strong>stationary assumption</strong>.</p>
<p>We can define this Markov chain, using its <strong>initial state probabilities</strong>, i.e. the CPT of $X_1$, and transition probabilities.</p>
<p>Like we learned before, we can calculate the <strong>joint distribution</strong> as:</p>
\begin{align*}
P(X_1, X_2, ..., X_T) &amp;= P(X_1)P(X_2|X_1)P(X_3|X_2)...P(X_T|X_{T-1}) \\
&amp;= P(X_1) \prod_{i=2}^T{P(X_i|X_{i-1})}
\end{align*}<p>This represents the probability of a sequence of events. We can use this measure to quantify <em>how likely the world we perceived is</em>.</p>
<p>Remember this model relies on the Markov property we mentioned earlier. Obviously, if this assumption is far-fetched, we have to make a more complex bayes net, and thus, the resulting joint distribution would have been different.</p>
<p>The most general formula we can write for a process, is when we take into account the effect of every previous state, i.e.</p>
\begin{align*}
P(X_1, X_2, ..., X_T) &amp;= P(X_1)P(X_2|X_1)P(X_3|X_2, X_1)...P(X_T|X_{T-1},...,X_1) \\
&amp;= P(X_1) \prod_{i=2}^T{P(X_i|X_{i-1},...,X_1)}
\end{align*}<p>You can simply prove that the two statements are equal, when $X_i \perp X_{i-2},...,X_1 | X_{i-1}$.</p>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h4 id="Example">Example<a class="anchor-link" href="#Example">¶</a></h4><p><img alt="Weekly Weather" src="/notes/assets/notebooks/11_temporal_probability_models/resource/weather_example.png"/>
Let's have an example to clear the air. We assume that changes of the weather is a Markov process, i.e. its state relies solely on its last step. So we make our snapshots everyday. We also that weather is classified into two states, namely rain and sun. Moreover, the <em>initial state probabilities</em> are defined by:</p>
<table>
<thead><tr>
<th style="text-align:center">state</th>
<th style="text-align:center">probability</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">sun</td>
<td style="text-align:center">1.0</td>
</tr>
<tr>
<td style="text-align:center">rain</td>
<td style="text-align:center">0.0</td>
</tr>
</tbody>
</table>
<p>And we assume that the <em>dynamics</em> for this problem are:</p>
<table>
<thead><tr>
<th style="text-align:center">X_{t-1}</th>
<th style="text-align:center">X_t</th>
<th style="text-align:center">P(X_t\</th>
<th>X_{t-1})</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">sun</td>
<td style="text-align:center">sun</td>
<td style="text-align:center">0.9</td>
</tr>
<tr>
<td style="text-align:center">sun</td>
<td style="text-align:center">rain</td>
<td style="text-align:center">0.1</td>
</tr>
<tr>
<td style="text-align:center">rain</td>
<td style="text-align:center">sun</td>
<td style="text-align:center">0.3</td>
</tr>
<tr>
<td style="text-align:center">rain</td>
<td style="text-align:center">rain</td>
<td style="text-align:center">0.7</td>
</tr>
</tbody>
</table>
<p>We can also, represent this CPT as depicted by figures below.</p>
<p><img alt="Representation 1" src="/notes/assets/notebooks/11_temporal_probability_models/resource/represent_2.png"/></p>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<details>
<summary> * What is probability distribution after one step? (Click for solution!)</summary>
  \begin{align*}
    P(X_2=sun) &amp;= P(X_2=sun|X_1=sun)P(X_1=sun) + P(X_2=sun|X_1=rain)P(X_1=rain) \\
    &amp;= 0.9 \times 1.0 + 0.1 \times 0.0 = 0.9
  \end{align*}
</details><details>
<summary> * What's $P(X)$ on some day $t$? (Click for solution!)</summary>
  To answer this question, we use mini-forward algorithm, introduced below.
</details>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Mini-Forward-Algorithm">Mini-Forward Algorithm<a class="anchor-link" href="#Mini-Forward-Algorithm">¶</a></h3><p>The problem we're trying to find solution for in this algorithm is the value of $P(X)$ on some day $t$. Mini-Forward Algorithm uses dynamic programming to find answer for this question.</p>
<p>$P(X_1)$ is known to us. We successively calculate probability of $P(X_t)$.</p>
\begin{align*}
P(X_t) &amp;= \sum_{x_{t-1}} P(x_{t-1}, x_t) \\
&amp;= \sum_{x_{t-1}} P(x_t|x_{t-1})P(x_{t-1})
\end{align*}<p>This is like we are <em>simulating</em> the transition for every day.</p>
<p>An execution of this algorithm up to $t=4$ has been done below.</p>
<p><img alt="mini-forward execution" src="/notes/assets/notebooks/11_temporal_probability_models/resource/mini-forward.png"/></p>
<p>Let's put it into code.</p>
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [4]:</div>
<div class="inner_cell">
<div class="input_area">
<div class="highlight hl-ipython3"><pre><span></span><span class="n">states</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'sun'</span><span class="p">,</span> <span class="s1">'rain'</span><span class="p">]</span>

<span class="n">transition</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">'sun'</span><span class="p">:</span> <span class="p">{</span><span class="s1">'sun'</span><span class="p">:</span> <span class="mf">0.9</span><span class="p">,</span> <span class="s1">'rain'</span><span class="p">:</span> <span class="mf">0.1</span><span class="p">},</span>
    <span class="s1">'rain'</span><span class="p">:{</span><span class="s1">'sun'</span><span class="p">:</span> <span class="mf">0.3</span><span class="p">,</span> <span class="s1">'rain'</span><span class="p">:</span> <span class="mf">0.7</span><span class="p">}</span>
<span class="p">}</span>

<span class="k">def</span> <span class="nf">mini_forward</span><span class="p">(</span><span class="n">initial</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">initial</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">t</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">p</span> <span class="o">=</span> <span class="p">{</span><span class="n">state</span><span class="p">:</span> <span class="nb">sum</span><span class="p">([</span><span class="n">transition</span><span class="p">[</span><span class="n">last_state</span><span class="p">][</span><span class="n">state</span><span class="p">]</span> <span class="o">*</span> <span class="n">p</span><span class="p">[</span><span class="n">last_state</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">last_state</span> <span class="ow">in</span> <span class="n">states</span><span class="p">])</span> <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">states</span><span class="p">}</span>
    <span class="k">return</span> <span class="n">p</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Next, we want to calculate the state's probabilities for $t=10000$ with several initial states.</p>
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [12]:</div>
<div class="inner_cell">
<div class="input_area">
<div class="highlight hl-ipython3"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">mini_forward</span><span class="p">({</span><span class="s1">'sun'</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="s1">'rain'</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">},</span> <span class="mi">10000</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">mini_forward</span><span class="p">({</span><span class="s1">'sun'</span><span class="p">:</span> <span class="mf">0.5</span><span class="p">,</span> <span class="s1">'rain'</span><span class="p">:</span> <span class="mf">0.5</span><span class="p">},</span> <span class="mi">10000</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">mini_forward</span><span class="p">({</span><span class="s1">'sun'</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span> <span class="s1">'rain'</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">},</span> <span class="mi">10000</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<div class="output_wrapper">
<div class="output">
<div class="output_area">
<div class="prompt"></div>
<div class="output_subarea output_stream output_stdout output_text">
<pre>{'sun': 0.7500000000000007, 'rain': 0.2500000000000001}
{'sun': 0.7500000000000003, 'rain': 0.2500000000000001}
{'sun': 0.7500000000000003, 'rain': 0.2500000000000001}
</pre>
</div>
</div>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>It seems like no matter what initial value we choose, we end up with days that are 75% sunny. (Go ahead and test some initial values of your own.</p>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Stationary-Distributions">Stationary Distributions<a class="anchor-link" href="#Stationary-Distributions">¶</a></h3><p>A stationary distribution is a specific entity which is unchanged by the effect of some matrix or operator.</p>
<p>Regarding our topic, it's a special distribution for a Markov chain, such that if the chain starts with its stationary distribution, the marginal distribution of all states at any time will always be the same stationary distribution. Assuming irreducibility, the stationary distribution is always unique if it exists.</p>
<p><img alt="stationary decorative" src="/notes/assets/notebooks/11_temporal_probability_models/resource/stationary-decorative.png"/></p>
<p>For most chains, influence of the initial distribution gets less and less over time and the distribution we end up in is independent of the initial distribution. This is the so-called <strong>stationary distribution</strong>. Note that regarding its definition, it satisfies:</p>
$$P(X_\infty) = P(X_{\infty +1}) = \sum_x P(X|x)P(X_\infty)$$
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h4 id="Example">Example<a class="anchor-link" href="#Example">¶</a></h4><p>Let's prove that for the previous example, the stationary distribution is really what we guessed.</p>
\begin{cases}
P_\infty(sun) = P(sun|sun)P_\infty(sun) + P(sun|rain)P_\infty(rain) \\
P_\infty(rain) = P(rain|sun)P_\infty(sun) + P(rain|rain)P_\infty(rain)
\end{cases}<p>
\begin{cases}
P_\infty(sun) = 0.9P_\infty(sun) + 0.3P_\infty(rain) \\
P_\infty(rain) = 0.1P_\infty(sun) + 0.7P_\infty(rain)
\end{cases} 
\begin{cases}
P_\infty(sun) = 3P_\infty(rain) \\
P_\infty(rain) = \frac{1}{3}P_\infty(sun)
\end{cases}</p>
<p>Note that $P_\infty(sun) + P_\infty(rain) = 1$, thus</p>
\begin{align*}
\begin{cases}
P_\infty(sun) = 0.75 \\
P_\infty(rain) = 0.25
\end{cases} Q.E.D
\end{align*}
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h4 id="Applications">Applications<a class="anchor-link" href="#Applications">¶</a></h4><h5 id="Web-Link-Analysis">Web Link Analysis<a class="anchor-link" href="#Web-Link-Analysis">¶</a></h5><p>Assume we use web pages as our state. We start from a uniformly random web page, and in each step change the state to some other uniformly random web page with probability $c$, and follow a random outlink in the web page with probability $1-c$.</p>
<p>It can be seen that we'll spend more time on web pages that are highly reachable. e.g. since many sites use Flash, you can probably find a path from any site to Acrobat Flash download page.</p>
<p>In fact, since this transitions are random, leading it to a certain site, requires making path from many sites to it, which is practically impossible, so it's somewhat robust to link spam.</p>
<p>Google 1.0 returned the set of pages containing all your keywords in decreasing rank (the time spent on that web page). Nowadays, all search engines use link analysis along with many other factors. (rank is actually getting less important over time)</p>
<h5 id="Gibs-Sampling">Gibs Sampling<a class="anchor-link" href="#Gibs-Sampling">¶</a></h5><p>We define:</p>
<ul>
<li>Each state as a set of all random and query variables, i.e. $\{X_1,...,X_n\} = H \cup Q$</li>
<li>Transitions as resampling one of the variables regarding all its parents, i.e we resample $x$ according to:
$$P(X_i|X_1,X_2,...X_n, E_1, ..., E_m)$$ Where $E_i$ is an evidence.</li>
</ul>
<p>As the time passes by our state will converge to a valid state regarding the problem's Bayes net.</p>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Hidden-Markov-Model">Hidden Markov Model<a class="anchor-link" href="#Hidden-Markov-Model">¶</a></h3><p>Usually if we look at the problem's input, it doesn't yield a Markov chain. But still, there is hope.</p>
<p>If the problem has a superior state that is a Markov process, we can make an assumption about this superior state, our <strong>belief</strong>, and update it as we <strong>observe</strong> problem's inputs.</p>
<p><img alt="Hidden Markov Model" src="/notes/assets/notebooks/11_temporal_probability_models/resource/hmm.png"/></p>
<p>To model this system, we start with a simple Markov chain, and at each state, add a new node for the inputs of the problem such as agent's sensors, etc. which is solely relied on its state (i.e. $P(E_t|X_{0:t},E_{0:t-1}) = P(E_t|X_t)$. This property is called <strong>sensor Markov assumption</strong>).</p>
<p>You can see a sample Hidden Markov Model (<strong>HMM</strong>) above.</p>
<h4 id="Example">Example<a class="anchor-link" href="#Example">¶</a></h4><p>Let's use the weather problem to clear the air again. Imagine that you are the security guard stationed at a secret  underground installation. You want to know whether it’s raining today, but your only access to the outside world occurs each morning when you see the director coming in with, or without, an umbrella. For each day $t$, the set $E_t$ thus contains a single evidence variable $Umbrella_t$ or $U_t$ for short (whether the umbrella appears), and the set $X_t$ contains a single state variable $Rain_t$ or $R_t$ for short (whether it is raining).</p>
<p><img alt="HMM Weather Example" src="/notes/assets/notebooks/11_temporal_probability_models/resource/hmm-weather.png"/></p>
<p>This Bayes net can help us to find whatever query we have.</p>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h4 id="Joint-Distribution-of-an-HMM">Joint Distribution of an HMM<a class="anchor-link" href="#Joint-Distribution-of-an-HMM">¶</a></h4><p>Like Markov chain, we write the joint distributions of all variables:
\begin{align*}
P(X_1, E_1, ... ,X_T, E_T) &amp;= P(X_1)P(E_1|X_1) \prod_{t=2}^T P(X_t|X_{t-1:0})P(E_t|X_{t:0}) \\
&amp;= P(X_1)P(E_1|X_1) \prod_{t=2}^T P(X_t|X_{t-1})P(E_t|X_t)
\end{align*}</p>
<p>Note how we used the sensor Markov assumption along with Markov property to simplify the result.</p>
<p>You remember from before that the sensor Markov assumption is $E_i \perp X_{i-1},...,X_1, E_{i-1},...,E_1 | X_{i}$.</p>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h4 id="Applications">Applications<a class="anchor-link" href="#Applications">¶</a></h4><h5 id="Speech-Recognition-HMMs">Speech Recognition HMMs<a class="anchor-link" href="#Speech-Recognition-HMMs">¶</a></h5><p>Hidden Markov Models (HMMs) provide a simple and effective framework for modelling time-varying spectral vector sequences. As a consequence, almost all present day large vocabulary continuous speech recognition (LVCSR) systems are based on HMMs.</p>
<p>We use acoustic signals as our observation, and specific positions in words as our states (so we have tens of thousands of states).</p>
<h5 id="Machine-Translation-HMMs">Machine Translation HMMs<a class="anchor-link" href="#Machine-Translation-HMMs">¶</a></h5><p>On a basic level, machine translation performs mechanical substitution of words in one language for words in another, but that alone rarely produces a good translation because recognition of whole phrases and their closest counterparts in the target language is needed. Not all words in one language have equivalent words in another language, and many words have more than one meaning.</p>
<p>Here, we observe words, and our states are translation options.</p>
<h5 id="Robot-Tracking">Robot Tracking<a class="anchor-link" href="#Robot-Tracking">¶</a></h5><p>In this application, we want to localize a robot using the range readings its sensors provide. (sesors provide our observation)</p>
<p>Here, states are possible possitions of the robot on the map.</p>
</div>
</div>
</div>
