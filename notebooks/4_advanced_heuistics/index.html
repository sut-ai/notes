---
layout: content
metadata: notebooks_4_advanced_heuistics_metadata
colab: https://colab.research.google.com/github/sut-ai/notes/blob/master/notebooks/4_advanced_heuistics//index.ipynb
---

<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<div style="direction:rtl;line-height:300%;">
<font face="XB Zar" size="5">
<div align="center">
<font face="IranNastaliq" size="30">
<p></p>
<b>Advanced Heuristics</b>
<img src="/notes/assets/pics/opening.jpg" style="float:center; width:60%"/>
<p></p>
</font>
<font>
By Fatemeh Bahrani, Rosta Roghani, Yasaman Shaykhan
            </font>
<p></p>
</div>
</font></div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><p></p>
<br/></p>
<div id="sec_intro" style="line-height:300%;">
<font face="XB Zar" size="5">
<font color="#FF7500" size="6">
Heuristic Functions
        </font>
<br/>
<hr/>
<font>
<b>Definition:</b>
</font>
<p></p>
For systematic search in AI, it is common to use heuristic functions. These functions provide a guide to the status of the remaining path in each mode to the target mode. With such a function, our search will be smarter. A*, Hill climbing, Simmulated Annealing, and Beam Search are some of the most famous algorithms that use heuristics.
<br/>   
This function takes a state of the environment and estimates the shortest path of the node to the target and returns it. This function is one of the search criteria for selecting estimates of the cost of the route so that it succeeds in reaching the nearest goal. The better heuristic function is, the fewer mistakes we make and the faster we get the answer. The most common way that transfers problem information to a search operation is called a heuristic function, usually denoted by h (n). 
    </font>
</div>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><p></p></p>
<div id="sec_intro" style="line-height:300%;">
<font face="XB Zar" size="5">
In the case of heuristic functions, two features are important; Being <b>monotonic</b> and <b>admissible</b>.
        <br/>
● Being “Admissible” means that the heuristic function underestimates the cost of reaching the goal from a node. The advantage of having such feature in A* (For example) is that if there is a path from s to a goal state, A* terminates by finding an optimal path.
        <img src="/notes/assets/pics/admissable.png" style="float:center; width:60%"/>
</font>
</div>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><p></p></p>
<p><div id="sec_intro" style="line-height:300%;">
<font face="XB Zar" size="5">
● Being “Monotonic” means that f values never decrease from node to descendants. 
    </font>
</div>
<br/></p>
<figure class="half" style="display:flex">
<img src="/notes/assets/pics/monotonic1.png" style="width:50%"/>
<img src="/notes/assets/pics/monotonic2.png" style="width:50%"/>
</figure>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><p></p>
<br/></p>
<div id="sec_intro" style="line-height:300%;">
<font face="XB Zar" size="5">
Note that being monotonic is a sufficient condition for being admissible. (Nonetheless, most admissible heuristics are also consistent.) 
        <br/>
<b>Proof:</b>
<img src="/notes/assets/pics/mono-admiss.png" style="float:center; width:90%"/>
        Like admissibility, being monotonic also helps to find an optimal path to the state it selects for expansion.
    </font>
</div>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><p></p>
<hr/></p>
<div id="sec_intro" style="line-height:300%;">
<font face="XB Zar" size="5">
<b>How to make a heuristic function Monotonic (or Consistent):</b>
<img src="/notes/assets/pics/makeconsistant.png" style="float:center; width:90%"/>
<br/>
    In the case of Tree Search, only the condition of h being admissible is required. Two conditions are required for the h function in Graph Search: 1. being Admissible and 2. being Monotonic. 
<br/><br/>
<font color="red" size="5"> <b>∗</b> </font>Finding the optimal h (h∗) is difficult in some cases, and this is an important choice. The closer h is to h∗, the fewer nodes open. If h ≤ h*, it will find the optimal answer. If h and h∗ are equal, it only opens the path to the optimal answer. But if h &gt; h∗ , it may not find the optimal answer. 
        <br/>
        Counterexample:
         <img src="/notes/assets/pics/counter.jpg" style="float:center; width:50%">
</img></font>
</div>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><p></p><hr/></p>
<div id="sec_intro" style="line-height:300%;">
<font face="XB Zar" size="5">
<b>8-puzzle; An Important Example:</b>
<br/>
        Given a 3×3 board with 8 tiles (every tile has one number from 1 to 8) and one empty space. The objective is to place the numbers on tiles to match the final configuration using the empty space. We can slide four adjacent (left, right, above, and below) tiles into the empty space. 
For example:
    <img src="/notes/assets/pics/puzzle8init.png" style="width:30%"/>
        24-puzzle could be defined as well. (Size of the board is 5×5 instead of 3×3 and it has the same rules for moving.)
        <br/>
        For more information, click <a href="https://www.geeksforgeeks.org/8-puzzle-problem-using-branch-and-bound/">here</a>
</font>
</div>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><br/></p>
<p><p></p>
<br/></p>
<div id="sec_intro" style="line-height:300%;">
<font face="XB Zar" size="5">
<font color="#FF7500" size="6">
Heuristic Dominance
        </font>
<br/>
<hr/>
<p></p>
Now we are going to introduce a new concept that is used to compare the performance of two heuristic functions.
        <br>
        ● If h<sub>2</sub>  ≥ h<sub>1</sub> for all n (both admissable) then h<sub>2</sub> <font color="red"> dominates </font> h<sub>1</sub> →  h<sub>2</sub> is better for search
        <br/>
        ● Typical earch costs (average number of nodes axpanded) for 8-puzzle problem
        <br/>
             
        d = 12 : <br/>
              IDS = 3,644,035 nodes <br/>
              A∗(h<sub>1</sub>) = 227 nodes <br/>
              A∗(h<sub>2</sub>) = 73 nodes <br/>
             
        d = 24 : <br/>
              IDS = too many nodes <br/>
              A∗(h<sub>1</sub>) = 39,135 nodes <br/>
              A∗(h<sub>2</sub>) = 1,641 nodes
    </br></font>
</div>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><p></p><hr/></p>
<div id="sec_intro" style="line-height:300%;">
<font face="XB Zar" size="5">
<b>Heuristic function design constraint relaxation:</b>
<br/>
        There are ways to improve a heuristic function. One of these ways is relaxation. In this method, we look for the answer in a space with fewer terms and conditions; and instead of minimizing the cost, we find the lower bound. As a result, it has become easier to solve.
    <img src="/notes/assets/pics/constraint.png" style="width:80%"/>
        In general, admissible heuristic functions represent the cost of exact solutions to simplified or relaxed versions of the original problem (Pearl, 1984). For example, in a sliding tile puzzle (like 8-puzzle), to move a tile from position x to position y, x and y must be adjacent, and position y must be empty. By ignoring the empty constraint, we get a simplified problem where any tile can move to any adjacent position. We can solve any instance of this new problem optimally by moving each tile along the shortest path to its goal position, counting the number of moves made. The cost of such a solution is exactly the Manhattan distance from the initial state to the goal state. Since we removed a constraint on the moves, any solution to the original problem is also a solution to the simplified problem, and the cost of an optimal solution to the simplified problem is a lower bound on the cost of an optimal solution to the original problem. Thus, any heuristic derived in this way is admissible. 
        <br/>
<br/>
<b>More Relaxed Heuristic Functions</b>:
        <br/>
  − Pattern Database Heuristics <br/>
  − Linear Conflict Heuristics <br/>
  − Gaschnig’s Heuristics
    </font>
</div>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><br/></p>
<p><p></p>
<br/></p>
<div id="sec_intro" style="line-height:300%;">
<font face="XB Zar" size="5">
<font color="#09C42B" size="5.5">
Pattern Database:
        </font>
<br/>
<p></p>
We can consider a subset of the search space and consider others as "don't care". In this case, the interaction between the cells inside this subset is considered and the independence is reduced. The function h can then be obtained by combining "h"s from different subsets (search space separation).

Pattern databases are for exploratory estimation of storing state-to-target distances in state space. Their effectiveness depends on the choice of basic patterns. If it is possible to divide the subsets into separate subsets so that each operator only affects the subsets in one subset, then we can have a more acceptable exploration performance. We used this method to improve performance in 15-puzzles with a coefficient of more than 2000 and to find optimal solutions for 50 random samples of 24-puzzles.
        <img src="/notes/assets/pics/15puzzle.png" style="float:center; width:80%"/>

 How do we combine the “h” s of the separated subset of state space?

  − MAX: Which has diminishing. <br>
  − ADD: In this case, the limitation is removed and it is admissible. <br/>
Using a Pattern Database helps us solve many problems, but it is flawed in very large cases and is not scalable.
        <br/><br/>
<font color="#09C42B" size="5.5">
            Drawbacks of Pattern DBs:
        </font>
<br/>
            ● Since we can only take max <br/>
  ● Diminishing returns on additional DBs <br/>
  ● Consider bigger problem instances. <br/>
      ● Subproblems should be small to be scalable. <br/>
      ● If hi(n) from each database is at most x, then maxi hi would be at most x. <br/>
        ● Would like to be able to add values 
    </br></font>
</div>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><br/></p>
<p><p></p>
<br/></p>
<div id="sec_intro" style="line-height:300%;">
<font face="XB Zar" size="5">
<font color="#09C42B" size="5.5">
Disjoint of Pattern DBs:
        </font>
<br/>
<p></p>
What if we make patterns be disjoint sets? Can we take summation of heuristics by pattern DBs as an admissible heuristic? In order to fix this, take number of moves made to the specified tiles as hi instead.
        <img src="/notes/assets/pics/disjoint.png" style="float:center; width:80%"/>

Why does summation result in an admissible heuristic in that case?
        <br>
<b> Proof: </b>
<br/>
<center>
            h∗(s<sub>0</sub>) = min n<sub>1</sub> + ... + n<sub>n</sub> <br/>
            s.t. s<sub>n</sub> ∈ G, a<sub>i</sub>∈ A<sub>s<sub>i</sub></sub>, s<sub>i</sub>∈ S, s<sub>1</sub> = s<sub>0</sub> <br/>
            s<sub>i + 1</sub> = succ(s<sub>i</sub>,a<sub>i</sub>) <br/>
            n<sub>i</sub> = |{a<sub>k</sub> | s<sub>k</sub>(a<sub>k</sub>(1)) ∈ P<sub>i</sub>}| <br/>
            A<sub>s<sub>i</sub></sub> = {(j,k)| 1 ≤ j ≤ 8 , 1 ≤ k ≤ 9 , j ∈ N<sub>empty</sub>(s<sub>i</sub>), k ∈ I<sub>empty</sub>(s<sub>i</sub>)} <br/>
            ⇒ <br/>
             h∗(s<sub>0</sub>) ≥ min n<sub>1</sub> + ... + min n<sub>n</sub> <br/>
            s.t. s<sub>n</sub> ∈ G, a<sub>i</sub>∈ A<sub>s<sub>i</sub></sub>, s<sub>i</sub>∈ S, s<sub>1</sub> = s<sub>0</sub> <br/>
            s<sub>i + 1</sub> = succ(s<sub>i</sub>,a<sub>i</sub>) <br/>
            n<sub>i</sub> = |{a<sub>k</sub> | s<sub>k</sub>(a<sub>k</sub>(1)) ∈ P<sub>i</sub>}| <br/>
            A<sub>s<sub>i</sub></sub> = {(j,k)| 1 ≤ j ≤ 8 , 1 ≤ k ≤ 9 , j ∈ N<sub>empty</sub>



Manhattan Dist. is a trivial example of a disjoint DBs, where each group contains only a single tile. As a general rule, when partitioning the tiles, we want to group tiles that are near each other in the goal state, since these tiles will interact the most with one another. 
Using this method, the 15-puzzle problem is solved 2000 times and the 24-puzzle problem is 12 million times faster
    </center></br></font>
</div>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><p></p>
<br/></p>
<div id="sec_refs" style="line-height:300%;">
<font face="XB Zar" size="5">
<font color="#FF7500" size="6">
Resources
        </font>
<hr/>
<ul>
<li>
            https://cse.iitkgp.ac.in/~pallab/ai.slides/lec3a.pdf
            </li>
<li>
           www.cs.stackexchange.com/questions/63481/how-does-consistency-imply-that-a-heuristic-is-also-admissible
            </li>
<li>
            www.courses.cs.washington.edu/courses/cse473/12sp/slides/04-heuristics.pdf           
            </li>
<li>
            www.sciencedirect.com/science/article/pii/S0004370201000923
            </li>
<li>
            https://www.geeksforgeeks.org/8-puzzle-problem-using-branch-and-bound/
            </li>
<li>
            www.researchgate.net/publication/222830183_Disjoint_pattern_database_heuristics
            </li>
<li>
            www.aaai.org/Papers/JAIR/Vol22/JAIR-2209.pdf
            </li>
<li>
            www.link.springer.com/chapter/10.1007/978-3-540-74128-2_3
            </li>
<li>
               www.stackoverflow.com/questions/46554459/intuitively-understanding-why-consistency-is-required-for-optimality-in-a-searc
            </li>
</ul>
</font>
</div>
</div>
</div>
</div>
</div>
